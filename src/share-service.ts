import axios from 'axios';
import { HtmlData } from './html-generator.js';
import { SessionData } from './types.js';

export interface ShareData {
  title: string;
  createdAt: string;
  sessionInfo: ShareSessionInfo;
  techStack: ShareTechStack;
  prompts: SharePrompt[];
  metadata: ShareMetadata;
  claudeMd?: string;
  models?: string[];  // List of models used
  mcpServers?: ShareMCPServer[];  // MCP servers if any
  toolStats?: ShareToolStats;  // Tool usage statistics
}

export interface ShareSessionInfo {
  totalPrompts: number;
  timeRange?: string;
  sources?: string[];
  projectPath?: string;
  claudeProjectPath?: string;
}

export interface ShareTechStack {
  languages: string[];
  frameworks: string[];
  tools: string[];
  databases: string[];
}

export interface SharePrompt {
  id: number;
  content: string;
  timestamp: string;
  sourceFile?: string;
  fileDiffs: ShareFileDiff[];
  usage?: {
    input_tokens?: number;
    output_tokens?: number;
    cache_creation_input_tokens?: number;
    cache_read_input_tokens?: number;
    total_tokens?: number;
  };
  responseTimeMs?: number;
  isAutoGenerated?: boolean;
  model?: string;  // Model used for this response
  toolCalls?: string[];  // Tools called in this prompt
}

export interface ShareMCPServer {
  name: string;
  tools: string[];
  callCount: number;
}

export interface ShareToolStats {
  totalCalls: number;
  byTool: { [toolName: string]: number };
  mcpCalls: number;
  regularCalls: number;
}

export interface ShareFileDiff {
  path: string;
  diff: string;
  additions?: number;
  deletions?: number;
}

export interface ShareMetadata {
  generatedBy: string;
  version: string;
  platform: string;
}

export interface ShareResponse {
  id?: string;
  url?: string;
  message?: string;
  error?: string;
}

export function transformToShareData(htmlData: HtmlData, sessionData: SessionData): ShareData {
  const { promptsWithChanges, sessionInfo, techStack } = htmlData;
  
  // Count additions and deletions from diff
  function countDiffChanges(diff: string): { additions: number; deletions: number } {
    const lines = diff.split('\n');
    let additions = 0;
    let deletions = 0;
    
    lines.forEach(line => {
      if (line.startsWith('+') && !line.startsWith('+++')) {
        additions++;
      } else if (line.startsWith('-') && !line.startsWith('---')) {
        deletions++;
      }
    });
    
    return { additions, deletions };
  }
  
  const prompts: SharePrompt[] = promptsWithChanges.map((item, index) => {
    const fileDiffs: ShareFileDiff[] = item.fileDiffs.map(file => {
      const { additions, deletions } = countDiffChanges(file.diff);
      return {
        path: file.path,
        diff: file.diff,
        additions,
        deletions
      };
    });
    
    // Find the next assistant response to get usage and response time
    const promptIndex = sessionData.prompts.findIndex(p => 
      p.content === item.prompt && 
      p.timestamp === item.timestamp
    );
    
    let usage = undefined;
    let responseTimeMs = undefined;
    let model = undefined;
    let toolCalls = undefined;
    
    // Find the corresponding prompt in sessionData
    const originalPrompt = sessionData.prompts[promptIndex];
    const isAutoGenerated = originalPrompt?.isAutoGenerated;
    
    if (promptIndex !== -1 && promptIndex < sessionData.prompts.length - 1) {
      const nextPrompt = sessionData.prompts[promptIndex + 1];
      if (nextPrompt.role === 'assistant') {
        usage = nextPrompt.usage;
        responseTimeMs = nextPrompt.responseTimeMs;
        model = nextPrompt.model;
        toolCalls = nextPrompt.toolCalls;
      }
    }
    
    return {
      id: index + 1,
      content: item.prompt,
      timestamp: item.timestamp || new Date().toISOString(),
      sourceFile: item.sourceFile,
      fileDiffs,
      usage,
      responseTimeMs,
      isAutoGenerated,
      model,
      toolCalls
    };
  });
  
  // Calculate tool statistics
  let toolStats: ShareToolStats | undefined = undefined;
  if (sessionData.toolCalls && sessionData.toolCalls.length > 0) {
    const byTool: { [toolName: string]: number } = {};
    let mcpCalls = 0;
    
    sessionData.toolCalls.forEach(call => {
      byTool[call.name] = (byTool[call.name] || 0) + 1;
      if (call.isMCP) mcpCalls++;
    });
    
    toolStats = {
      totalCalls: sessionData.toolCalls.length,
      byTool,
      mcpCalls,
      regularCalls: sessionData.toolCalls.length - mcpCalls
    };
  }
  
  // Transform MCP servers data
  const mcpServers: ShareMCPServer[] | undefined = sessionData.metadata?.mcpServers?.map(server => ({
    name: server.name,
    tools: server.tools,
    callCount: server.tools.reduce((sum, toolName) => 
      sum + (toolStats?.byTool[toolName] || 0), 0)
  }));
  
  const shareData: ShareData = {
    title: 'Claude Code Prompts',
    createdAt: new Date().toISOString(),
    sessionInfo: {
      totalPrompts: sessionInfo?.totalPrompts || prompts.length,
      timeRange: sessionInfo?.timeRange,
      sources: sessionInfo?.sources,
      projectPath: sessionInfo?.projectPath || sessionData.metadata?.workingDirectory,
      claudeProjectPath: sessionInfo?.claudeProjectPath || sessionData.metadata?.claudeProjectPath
    },
    techStack: {
      languages: techStack?.languages || [],
      frameworks: techStack?.frameworks || [],
      tools: techStack?.tools || [],
      databases: techStack?.databases || []
    },
    prompts,
    metadata: {
      generatedBy: 'ccshare',
      version: '0.2.0',
      platform: sessionData.metadata?.platform || process.platform
    },
    models: sessionData.metadata?.models,
    mcpServers: mcpServers && mcpServers.length > 0 ? mcpServers : undefined,
    toolStats
  };
  
  return shareData;
}

export async function shareToAPI(shareData: ShareData, apiUrl: string = 'https://ccshare.cc/shares'): Promise<ShareResponse> {
  try {
    const response = await axios.post<ShareResponse>(apiUrl, shareData, {
      headers: {
        'Content-Type': 'application/json'
      },
      timeout: 10000 // 10 second timeout
    });
    
    return response.data;
  } catch (error: any) {
    if (error.response) {
      // Server responded with error
      return {
        error: error.response.data?.message || error.response.data?.error || `Server error: ${error.response.status}`
      };
    } else if (error.request) {
      // No response received
      return {
        error: 'No response from server. Make sure the API is running on localhost:3000'
      };
    } else {
      // Request setup error
      return {
        error: error.message || 'Failed to send request'
      };
    }
  }
}

export async function fetchFromSlug(slug: string, apiUrl: string = 'https://ccshare.cc/shares'): Promise<ShareData | null> {
  try {
    const response = await axios.get<ShareData>(`${apiUrl}/${slug}`, {
      headers: {
        'Accept': 'application/json'
      },
      timeout: 10000 // 10 second timeout
    });
    
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      console.error(`Share not found: ${slug}`);
    } else if (error.response) {
      console.error(`Server error: ${error.response.status}`);
    } else {
      console.error(`Failed to fetch share: ${error.message}`);
    }
    return null;
  }
}